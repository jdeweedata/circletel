/**
 * Corporate Site Service
 *
 * Handles CRUD operations for corporate sites (child locations).
 * Includes bulk import functionality for CSV uploads.
 */

import { createClient } from '@/lib/supabase/server'
import {
  CorporateSite,
  CreateCorporateSiteParams,
  UpdateCorporateSiteParams,
  ListSitesParams,
  PaginatedResult,
  BulkImportSiteRow,
  BulkImportResult,
} from './types'

// ============================================================================
// Corporate Site Service
// ============================================================================

export class CorporateSiteService {
  /**
   * Create a new corporate site
   * Note: account_number and site_number are auto-generated by database trigger
   */
  static async create(params: CreateCorporateSiteParams): Promise<{
    success: boolean
    site?: CorporateSite
    error?: string
  }> {
    const supabase = await createClient()

    try {
      // Verify corporate exists
      const { data: corporate } = await supabase
        .from('corporate_accounts')
        .select('id, corporate_code')
        .eq('id', params.corporateId)
        .single()

      if (!corporate) {
        return {
          success: false,
          error: 'Corporate account not found',
        }
      }

      // Create site (account_number will be auto-generated by trigger)
      const { data, error } = await supabase
        .from('corporate_sites')
        .insert({
          corporate_id: params.corporateId,
          site_name: params.siteName,
          site_code: params.siteCode,
          site_contact_name: params.siteContactName,
          site_contact_email: params.siteContactEmail,
          site_contact_phone: params.siteContactPhone,
          installation_address: params.installationAddress,
          province: params.province || params.installationAddress.province,
          coordinates: params.coordinates,
          package_id: params.packageId,
          monthly_fee: params.monthlyFee,
          has_rack_facility: params.hasRackFacility ?? false,
          has_access_control: params.hasAccessControl ?? false,
          has_air_conditioning: params.hasAirConditioning ?? false,
          has_ac_power: params.hasAcPower ?? false,
          rfi_status: params.rfiStatus ?? 'not_ready',
          rfi_notes: params.rfiNotes,
          access_type: params.accessType ?? 'business_hours',
          access_instructions: params.accessInstructions,
          landlord_consent_url: params.landlordConsentUrl,
        })
        .select()
        .single()

      if (error) {
        console.error('Failed to create corporate site:', error)
        return { success: false, error: error.message }
      }

      return {
        success: true,
        site: this.mapSite(data),
      }
    } catch (error) {
      console.error('Error creating corporate site:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  /**
   * Get a site by ID
   */
  static async getById(id: string): Promise<CorporateSite | null> {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('corporate_sites')
      .select('*')
      .eq('id', id)
      .single()

    if (error || !data) {
      return null
    }

    return this.mapSite(data)
  }

  /**
   * Get a site by account number
   */
  static async getByAccountNumber(accountNumber: string): Promise<CorporateSite | null> {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('corporate_sites')
      .select('*')
      .eq('account_number', accountNumber.toUpperCase())
      .single()

    if (error || !data) {
      return null
    }

    return this.mapSite(data)
  }

  /**
   * Update a corporate site
   */
  static async update(
    id: string,
    params: UpdateCorporateSiteParams
  ): Promise<{
    success: boolean
    site?: CorporateSite
    error?: string
  }> {
    const supabase = await createClient()

    try {
      const updateData: Record<string, unknown> = {}

      // Map params to database columns
      if (params.siteName !== undefined) updateData.site_name = params.siteName
      if (params.siteCode !== undefined) updateData.site_code = params.siteCode
      if (params.siteContactName !== undefined) updateData.site_contact_name = params.siteContactName
      if (params.siteContactEmail !== undefined)
        updateData.site_contact_email = params.siteContactEmail
      if (params.siteContactPhone !== undefined)
        updateData.site_contact_phone = params.siteContactPhone
      if (params.installationAddress !== undefined)
        updateData.installation_address = params.installationAddress
      if (params.province !== undefined) updateData.province = params.province
      if (params.coordinates !== undefined) updateData.coordinates = params.coordinates
      if (params.status !== undefined) updateData.status = params.status
      if (params.packageId !== undefined) updateData.package_id = params.packageId
      if (params.monthlyFee !== undefined) updateData.monthly_fee = params.monthlyFee
      if (params.hasRackFacility !== undefined) updateData.has_rack_facility = params.hasRackFacility
      if (params.hasAccessControl !== undefined)
        updateData.has_access_control = params.hasAccessControl
      if (params.hasAirConditioning !== undefined)
        updateData.has_air_conditioning = params.hasAirConditioning
      if (params.hasAcPower !== undefined) updateData.has_ac_power = params.hasAcPower
      if (params.rfiStatus !== undefined) updateData.rfi_status = params.rfiStatus
      if (params.rfiNotes !== undefined) updateData.rfi_notes = params.rfiNotes
      if (params.accessType !== undefined) updateData.access_type = params.accessType
      if (params.accessInstructions !== undefined)
        updateData.access_instructions = params.accessInstructions
      if (params.landlordConsentUrl !== undefined)
        updateData.landlord_consent_url = params.landlordConsentUrl
      if (params.installedAt !== undefined) updateData.installed_at = params.installedAt
      if (params.installedBy !== undefined) updateData.installed_by = params.installedBy
      if (params.routerSerial !== undefined) updateData.router_serial = params.routerSerial
      if (params.routerModel !== undefined) updateData.router_model = params.routerModel

      const { data, error } = await supabase
        .from('corporate_sites')
        .update(updateData)
        .eq('id', id)
        .select()
        .single()

      if (error) {
        console.error('Failed to update corporate site:', error)
        return { success: false, error: error.message }
      }

      return {
        success: true,
        site: this.mapSite(data),
      }
    } catch (error) {
      console.error('Error updating corporate site:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  /**
   * List sites for a corporate with pagination and filters
   */
  static async list(params: ListSitesParams): Promise<PaginatedResult<CorporateSite>> {
    const supabase = await createClient()
    const page = params.page || 1
    const limit = Math.min(params.limit || 20, 100)
    const offset = (page - 1) * limit

    let query = supabase
      .from('corporate_sites')
      .select('*', { count: 'exact' })
      .eq('corporate_id', params.corporateId)

    // Apply filters
    if (params.status) {
      query = query.eq('status', params.status)
    }

    if (params.province) {
      query = query.eq('province', params.province)
    }

    if (params.search) {
      query = query.or(
        `site_name.ilike.%${params.search}%,account_number.ilike.%${params.search}%,site_code.ilike.%${params.search}%`
      )
    }

    const { data, error, count } = await query
      .order('site_number', { ascending: true })
      .range(offset, offset + limit - 1)

    if (error || !data) {
      return { data: [], total: 0, page, limit, totalPages: 0 }
    }

    const total = count || 0
    const totalPages = Math.ceil(total / limit)

    return {
      data: data.map(this.mapSite),
      total,
      page,
      limit,
      totalPages,
    }
  }

  /**
   * Get all sites for a corporate (no pagination)
   */
  static async getAllForCorporate(corporateId: string): Promise<CorporateSite[]> {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('corporate_sites')
      .select('*')
      .eq('corporate_id', corporateId)
      .order('site_number', { ascending: true })

    if (error || !data) {
      return []
    }

    return data.map(this.mapSite)
  }

  /**
   * Get sites by status for a corporate
   */
  static async getByStatus(corporateId: string, status: string): Promise<CorporateSite[]> {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('corporate_sites')
      .select('*')
      .eq('corporate_id', corporateId)
      .eq('status', status)
      .order('site_number', { ascending: true })

    if (error || !data) {
      return []
    }

    return data.map(this.mapSite)
  }

  /**
   * Bulk import sites from CSV data
   */
  static async bulkImport(
    corporateId: string,
    rows: BulkImportSiteRow[]
  ): Promise<BulkImportResult> {
    const supabase = await createClient()
    const errors: BulkImportResult['errors'] = []
    const sites: CorporateSite[] = []

    // Verify corporate exists
    const { data: corporate } = await supabase
      .from('corporate_accounts')
      .select('id')
      .eq('id', corporateId)
      .single()

    if (!corporate) {
      return {
        success: false,
        totalRows: rows.length,
        successCount: 0,
        failedCount: rows.length,
        errors: [{ row: 0, error: 'Corporate account not found' }],
        sites: [],
      }
    }

    // Process each row
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i]
      const rowNum = i + 1 // 1-indexed for user-friendly error messages

      try {
        // Validate required fields
        if (!row.siteName) {
          errors.push({ row: rowNum, error: 'Site name is required', data: row })
          continue
        }

        if (!row.city) {
          errors.push({ row: rowNum, error: 'City is required', data: row })
          continue
        }

        // Create site
        const { data, error } = await supabase
          .from('corporate_sites')
          .insert({
            corporate_id: corporateId,
            site_name: row.siteName,
            site_code: row.siteCode,
            site_contact_name: row.siteContactName,
            site_contact_phone: row.siteContactPhone,
            installation_address: {
              street: row.street,
              city: row.city,
              province: row.province,
              postal_code: row.postalCode,
            },
            province: row.province,
            monthly_fee: row.monthlyFee,
          })
          .select()
          .single()

        if (error) {
          errors.push({ row: rowNum, error: error.message, data: row })
        } else {
          sites.push(this.mapSite(data))
        }
      } catch (error) {
        errors.push({
          row: rowNum,
          error: error instanceof Error ? error.message : 'Unknown error',
          data: row,
        })
      }
    }

    return {
      success: errors.length === 0,
      totalRows: rows.length,
      successCount: sites.length,
      failedCount: errors.length,
      errors,
      sites,
    }
  }

  /**
   * Get distinct provinces for a corporate's sites
   */
  static async getProvinces(corporateId: string): Promise<string[]> {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('corporate_sites')
      .select('province')
      .eq('corporate_id', corporateId)
      .not('province', 'is', null)

    if (error || !data) {
      return []
    }

    // Get unique provinces
    const provinces = [...new Set(data.map((d) => d.province as string))]
    return provinces.sort()
  }

  /**
   * Update site status
   */
  static async updateStatus(
    id: string,
    status: CorporateSite['status']
  ): Promise<{ success: boolean; error?: string }> {
    const supabase = await createClient()

    const { error } = await supabase.from('corporate_sites').update({ status }).eq('id', id)

    if (error) {
      return { success: false, error: error.message }
    }

    return { success: true }
  }

  /**
   * Mark site as installed
   */
  static async markInstalled(
    id: string,
    installedBy: string,
    routerSerial?: string,
    routerModel?: string
  ): Promise<{ success: boolean; error?: string }> {
    const supabase = await createClient()

    const { error } = await supabase
      .from('corporate_sites')
      .update({
        status: 'active',
        installed_at: new Date().toISOString(),
        installed_by: installedBy,
        router_serial: routerSerial,
        router_model: routerModel,
      })
      .eq('id', id)

    if (error) {
      return { success: false, error: error.message }
    }

    return { success: true }
  }

  // --------------------------------------------------------------------------
  // Private Methods
  // --------------------------------------------------------------------------

  /**
   * Map database row to CorporateSite type
   */
  private static mapSite(row: Record<string, unknown>): CorporateSite {
    return {
      id: row.id as string,
      corporateId: row.corporate_id as string,
      siteNumber: Number(row.site_number) || 0,
      accountNumber: row.account_number as string,
      siteName: row.site_name as string,
      siteCode: row.site_code as string | null,
      siteContactName: row.site_contact_name as string | null,
      siteContactEmail: row.site_contact_email as string | null,
      siteContactPhone: row.site_contact_phone as string | null,
      installationAddress: row.installation_address as CorporateSite['installationAddress'],
      province: row.province as string | null,
      coordinates: row.coordinates as CorporateSite['coordinates'],
      status: row.status as CorporateSite['status'],
      pppoeCredentialId: row.pppoe_credential_id as string | null,
      pppoeUsername: row.pppoe_username as string | null,
      packageId: row.package_id as string | null,
      serviceId: row.service_id as string | null,
      monthlyFee: row.monthly_fee ? Number(row.monthly_fee) : null,
      hasRackFacility: Boolean(row.has_rack_facility),
      hasAccessControl: Boolean(row.has_access_control),
      hasAirConditioning: Boolean(row.has_air_conditioning),
      hasAcPower: Boolean(row.has_ac_power),
      rfiStatus: (row.rfi_status as CorporateSite['rfiStatus']) || 'not_ready',
      rfiNotes: row.rfi_notes as string | null,
      accessType: (row.access_type as CorporateSite['accessType']) || 'business_hours',
      accessInstructions: row.access_instructions as string | null,
      landlordConsentUrl: row.landlord_consent_url as string | null,
      installedAt: row.installed_at as string | null,
      installedBy: row.installed_by as string | null,
      routerSerial: row.router_serial as string | null,
      routerModel: row.router_model as string | null,
      createdAt: row.created_at as string,
      updatedAt: row.updated_at as string,
    }
  }
}
