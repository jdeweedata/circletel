/**
 * Invoice Generator Service
 * Creates invoices from signed contracts (B2B) and customer services (B2C)
 * 
 * Task Group 10: Invoice Generation & NetCash Payments (B2B)
 * Task 2.2: Customer Invoice Generation (B2C)
 */

import { createClient } from '@/lib/supabase/server';
import type { InvoiceLineItem as BillingLineItem, InvoiceType } from '@/lib/billing/types';
import { syncInvoiceToZohoBilling } from '@/lib/integrations/zoho/invoice-sync-service';

export interface InvoiceLineItem {
  description: string;
  quantity: number;
  unit_price: number;
  total: number;
}

export interface CreateInvoiceResult {
  invoiceId: string;
  invoiceNumber: string;
  totalAmount: number;
  items: InvoiceLineItem[];
}

/**
 * Creates an invoice from a signed contract
 *
 * Line items:
 * 1. Installation Fee (from contract.installation_fee)
 * 2. Router (if contract.router_included = true, R99.00)
 * 3. First Month Service Fee (from contract.monthly_recurring)
 *
 * @param contractId - UUID of the signed contract
 * @returns Invoice details including ID, number, and total amount
 */
export async function createInvoiceFromContract(
  contractId: string
): Promise<CreateInvoiceResult> {
  const supabase = await createClient();

  // 1. Fetch contract and quote data
  const { data: contract, error: contractError } = await supabase
    .from('contracts')
    .select(`
      *,
      quote:business_quotes(*),
      customer:customers(*)
    `)
    .eq('id', contractId)
    .single();

  if (contractError || !contract) {
    throw new Error(`Contract not found: ${contractId}`);
  }

  // 2. Calculate line items from contract
  const items: InvoiceLineItem[] = [
    {
      description: 'Installation Fee',
      quantity: 1,
      unit_price: contract.installation_fee || 0,
      total: contract.installation_fee || 0
    }
  ];

  // Add router if included
  if (contract.router_included) {
    items.push({
      description: 'Router',
      quantity: 1,
      unit_price: 99.00,
      total: 99.00
    });
  }

  // Add first month service fee
  items.push({
    description: 'First Month Service Fee',
    quantity: 1,
    unit_price: contract.monthly_recurring || 0,
    total: contract.monthly_recurring || 0
  });

  // 3. Calculate totals
  const subtotal = items.reduce((sum, item) => sum + item.total, 0);
  const vatRate = 15.00;
  const vatAmount = Number((subtotal * (vatRate / 100)).toFixed(2));
  const totalAmount = Number((subtotal + vatAmount).toFixed(2));

  // 4. Set due_date = invoice_date + 7 days
  const invoiceDate = new Date();
  const dueDate = new Date(invoiceDate);
  dueDate.setDate(dueDate.getDate() + 7);

  // 5. Insert invoice record
  const { data: invoice, error: invoiceError } = await supabase
    .from('invoices')
    .insert({
      contract_id: contractId,
      customer_id: contract.customer_id,
      invoice_type: 'installation',
      items: JSON.stringify(items),
      subtotal: subtotal,
      vat_rate: vatRate,
      vat_amount: vatAmount,
      total_amount: totalAmount,
      status: 'draft',
      invoice_date: invoiceDate.toISOString().split('T')[0],
      due_date: dueDate.toISOString().split('T')[0]
    })
    .select()
    .single();

  if (invoiceError || !invoice) {
    throw new Error(`Failed to create invoice: ${invoiceError?.message}`);
  }

  // 6. Return invoice details (number auto-generated by database trigger)
  return {
    invoiceId: invoice.id,
    invoiceNumber: invoice.invoice_number,
    totalAmount: invoice.total_amount,
    items: items
  };
}

/**
 * Fetch invoice details by ID
 * Used for PDF generation and payment processing
 */
export async function getInvoiceById(invoiceId: string) {
  const supabase = await createClient();

  const { data: invoice, error } = await supabase
    .from('invoices')
    .select(`
      *,
      contract:contracts(*),
      customer:customers(*)
    `)
    .eq('id', invoiceId)
    .single();

  if (error || !invoice) {
    throw new Error(`Invoice not found: ${invoiceId}`);
  }

  return invoice;
}

/**
 * Update invoice status
 * Used by payment processor after successful payment
 */
export async function updateInvoiceStatus(
  invoiceId: string,
  status: 'draft' | 'sent' | 'unpaid' | 'partial' | 'paid' | 'overdue' | 'cancelled',
  paymentDetails?: {
    amount_paid: number;
    paid_date: string;
    payment_reference: string;
    payment_method?: string;
  }
) {
  const supabase = await createClient();

  const updateData: any = { status };

  if (paymentDetails) {
    updateData.amount_paid = paymentDetails.amount_paid;
    updateData.paid_date = paymentDetails.paid_date;
    updateData.payment_reference = paymentDetails.payment_reference;
    if (paymentDetails.payment_method) {
      updateData.payment_method = paymentDetails.payment_method;
    }
  }

  const { data, error } = await supabase
    .from('invoices')
    .update(updateData)
    .eq('id', invoiceId)
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to update invoice: ${error.message}`);
  }

  return data;
}

// =============================================================================
// Customer Invoice Generation (B2C)
// Task 2.2: Invoice Generation Service for Customer Dashboard
// =============================================================================

/**
 * Customer invoice generation parameters
 */
export interface GenerateCustomerInvoiceParams {
  customer_id: string;
  service_id?: string;
  invoice_type: InvoiceType;
  line_items: BillingLineItem[];
  period_start?: string; // ISO date string
  period_end?: string; // ISO date string
  due_days?: number; // Days until due (default: 7)
  billing_date?: string; // ISO date string - the actual debit/payment date
  invoice_days_before_billing?: number; // Days before billing_date to create invoice (default: 6)
}

/**
 * Customer invoice result
 */
export interface CustomerInvoiceResult {
  invoice_id: string;
  invoice_number: string;
  total_amount: number;
  vat_amount: number;
  due_date: string;
  pdf_url?: string;
}

/**
 * Generate customer invoice for recurring billing, installation, or pro-rata charges
 * 
 * Supports customer_invoices table structure with:
 * - Auto-generated invoice number (INV-YYYY-NNNNN)
 * - VAT calculation (15%)
 * - Line items (JSONB array)
 * - Due date calculation
 * 
 * @param params - Customer invoice generation parameters
 * @returns Created invoice details
 * 
 * @example
 * // Generate recurring monthly invoice
 * const invoice = await generateCustomerInvoice({
 *   customer_id: 'uuid',
 *   service_id: 'uuid',
 *   invoice_type: 'recurring',
 *   line_items: [{
 *     description: 'MTN Fibre 100Mbps - December 2025',
 *     quantity: 1,
 *     unit_price: 699.00,
 *     amount: 699.00,
 *     type: 'recurring'
 *   }],
 *   period_start: '2025-12-01',
 *   period_end: '2025-12-31'
 * });
 */
export async function generateCustomerInvoice(
  params: GenerateCustomerInvoiceParams
): Promise<CustomerInvoiceResult> {
  const supabase = await createClient();
  
  const {
    customer_id,
    service_id,
    invoice_type,
    line_items,
    period_start,
    period_end,
    due_days = 7,
    billing_date,
    invoice_days_before_billing = 6
  } = params;
  
  // Calculate subtotal from line items
  const subtotal = line_items.reduce((sum, item) => sum + item.amount, 0);
  
  // Calculate VAT (15% South African rate)
  const vat_rate = 15.00;
  const vat_amount = Math.round(subtotal * (vat_rate / 100) * 100) / 100;
  const total_amount = Math.round((subtotal + vat_amount) * 100) / 100;
  
  // Calculate dates
  // Business Rule: Invoice is created X days before the billing/debit date
  // - If billing_date is provided, invoice_date = billing_date - invoice_days_before_billing
  // - due_date = billing_date (the actual payment collection date)
  // - This gives customers time to review invoices before payment is collected
  let invoice_date: Date;
  let due_date: Date;
  
  if (billing_date) {
    // Use billing_date as the due date (when payment is collected)
    due_date = new Date(billing_date);
    // Invoice date is X days before billing date
    invoice_date = new Date(due_date);
    invoice_date.setDate(invoice_date.getDate() - invoice_days_before_billing);
  } else {
    // Fallback to legacy behavior: invoice today, due in X days
    invoice_date = new Date();
    due_date = new Date(invoice_date);
    due_date.setDate(due_date.getDate() + due_days);
  }

  // Validate dates to prevent Unix epoch or invalid dates
  if (isNaN(due_date.getTime()) || due_date.getFullYear() < 2000) {
    throw new Error(`Invalid due_date calculated: ${due_date}. billing_date=${billing_date}, due_days=${due_days}`);
  }
  if (isNaN(invoice_date.getTime()) || invoice_date.getFullYear() < 2000) {
    throw new Error(`Invalid invoice_date calculated: ${invoice_date}`);
  }

  // Insert invoice (invoice_number auto-generated by trigger)
  const { data: invoice, error } = await supabase
    .from('customer_invoices')
    .insert({
      customer_id,
      service_id,
      invoice_type,
      invoice_date: invoice_date.toISOString().split('T')[0],
      due_date: due_date.toISOString().split('T')[0],
      period_start,
      period_end,
      subtotal,
      vat_rate,
      vat_amount,
      total_amount,
      amount_paid: 0,
      line_items: line_items,
      status: 'unpaid'
    })
    .select()
    .single();
  
  if (error) {
    throw new Error(`Failed to generate customer invoice: ${error.message}`);
  }

  // Trigger async ZOHO Billing sync (background task, non-blocking)
  // Only sync manual invoice types (installation, pro_rata, equipment, adjustment)
  const syncableTypes: InvoiceType[] = ['installation', 'pro_rata', 'equipment', 'adjustment'];
  if (invoice?.id && syncableTypes.includes(invoice_type as InvoiceType)) {
    syncInvoiceToZohoBilling(invoice.id)
      .then((result) => {
        if (result.success) {
          console.log('[ZOHO Trigger] Invoice synced to ZOHO Billing:', result.zoho_invoice_id);
        } else {
          console.error('[ZOHO Trigger] Invoice sync failed:', result.error);
        }
      })
      .catch((error) => {
        console.error('[ZOHO Trigger] Invoice sync error:', error);
      });
  }

  return {
    invoice_id: invoice.id,
    invoice_number: invoice.invoice_number,
    total_amount: invoice.total_amount,
    vat_amount: invoice.vat_amount,
    due_date: invoice.due_date,
    pdf_url: invoice.pdf_url || undefined
  };
}

/**
 * Get customer invoice by ID with full details
 * 
 * @param invoice_id - Invoice UUID
 * @returns Invoice with customer and service details
 */
export async function getCustomerInvoice(invoice_id: string) {
  const supabase = await createClient();
  
  const { data: invoice, error } = await supabase
    .from('customer_invoices')
    .select(`
      *,
      customer:customers(
        id,
        first_name,
        last_name,
        email,
        phone,
        account_number
      ),
      service:customer_services(
        id,
        package_name,
        service_type,
        installation_address
      )
    `)
    .eq('id', invoice_id)
    .single();
  
  if (error || !invoice) {
    throw new Error(`Customer invoice not found: ${invoice_id}`);
  }
  
  return invoice;
}

/**
 * Update customer invoice status and payment details
 * 
 * @param invoice_id - Invoice UUID
 * @param status - New invoice status
 * @param payment_details - Payment information (if paid)
 */
export async function updateCustomerInvoiceStatus(
  invoice_id: string,
  status: 'unpaid' | 'paid' | 'partial' | 'overdue' | 'cancelled' | 'refunded',
  payment_details?: {
    amount_paid: number;
    paid_at: string;
    payment_reference: string;
    payment_method?: string;
  }
) {
  const supabase = await createClient();
  
  const updateData: any = {
    status,
    updated_at: new Date().toISOString()
  };
  
  if (payment_details) {
    updateData.amount_paid = payment_details.amount_paid;
    updateData.paid_at = payment_details.paid_at;
    updateData.payment_reference = payment_details.payment_reference;
    if (payment_details.payment_method) {
      updateData.payment_method = payment_details.payment_method;
    }
  }
  
  const { data, error } = await supabase
    .from('customer_invoices')
    .update(updateData)
    .eq('id', invoice_id)
    .select()
    .single();
  
  if (error) {
    throw new Error(`Failed to update customer invoice: ${error.message}`);
  }
  
  return data;
}

/**
 * Generate invoice line items for a service
 * 
 * Helper function to create standardized line items for different invoice types
 * 
 * @param invoice_type - Type of invoice
 * @param service - Service details
 * @param amount - Amount to charge
 * @param period - Billing period (optional)
 * @returns Array of line items
 */
export function buildInvoiceLineItems(
  invoice_type: InvoiceType,
  service: {
    package_name: string;
    monthly_price: number;
    installation_fee?: number;
    router_fee?: number;
  },
  amount?: number,
  period?: { start: string; end: string }
): BillingLineItem[] {
  const items: BillingLineItem[] = [];
  
  switch (invoice_type) {
    case 'installation':
      // Installation fee
      if (service.installation_fee && service.installation_fee > 0) {
        items.push({
          description: 'Installation Fee',
          quantity: 1,
          unit_price: service.installation_fee,
          amount: service.installation_fee,
          type: 'installation'
        });
      }
      
      // Router fee (if applicable)
      if (service.router_fee && service.router_fee > 0) {
        items.push({
          description: 'Router',
          quantity: 1,
          unit_price: service.router_fee,
          amount: service.router_fee,
          type: 'equipment'
        });
      }
      break;
    
    case 'recurring':
      // Monthly recurring charge
      const periodText = period
        ? ` - ${formatPeriod(period.start, period.end)}`
        : '';
      
      items.push({
        description: `${service.package_name}${periodText}`,
        quantity: 1,
        unit_price: service.monthly_price,
        amount: service.monthly_price,
        type: 'recurring'
      });
      break;
    
    case 'pro_rata':
      // Pro-rated charge
      const proRataPeriod = period
        ? ` (${formatPeriod(period.start, period.end)})`
        : '';
      
      items.push({
        description: `${service.package_name} - Pro-rata${proRataPeriod}`,
        quantity: 1,
        unit_price: amount || 0,
        amount: amount || 0,
        type: 'pro_rata'
      });
      break;
    
    case 'equipment':
      // Equipment charge
      items.push({
        description: 'Equipment',
        quantity: 1,
        unit_price: amount || 0,
        amount: amount || 0,
        type: 'equipment'
      });
      break;
    
    case 'adjustment':
      // Manual adjustment
      items.push({
        description: 'Account Adjustment',
        quantity: 1,
        unit_price: amount || 0,
        amount: amount || 0,
        type: 'adjustment'
      });
      break;
  }
  
  return items;
}

/**
 * Format billing period for display
 * 
 * @param start - Start date (ISO string)
 * @param end - End date (ISO string)
 * @returns Formatted period string
 * 
 * @example
 * formatPeriod('2025-12-01', '2025-12-31')
 * // Returns: "December 2025" or "1 Dec - 31 Dec 2025"
 */
function formatPeriod(start: string, end: string): string {
  const startDate = new Date(start);
  const endDate = new Date(end);
  
  // If same month, just show month and year
  if (startDate.getMonth() === endDate.getMonth() &&
      startDate.getFullYear() === endDate.getFullYear()) {
    return startDate.toLocaleDateString('en-ZA', {
      month: 'long',
      year: 'numeric'
    });
  }
  
  // Different months, show date range
  return `${startDate.toLocaleDateString('en-ZA', { day: 'numeric', month: 'short' })} - ${endDate.toLocaleDateString('en-ZA', { day: 'numeric', month: 'short', year: 'numeric' })}`;
}
