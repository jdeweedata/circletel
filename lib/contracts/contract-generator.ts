/**
 * Contract Generator
 * Task Group 6: Contract Generation & PDF with KYC Badge
 *
 * Creates contracts from approved quotes with KYC verification
 */

import { createClient } from '@/lib/supabase/server';
import type { ContractResponse } from './types';

interface QuoteData {
  id: string;
  quote_number: string;
  customer_id: string;
  service_address: string;
  contract_term: number;
  monthly_recurring: number;
  once_off_fee: number;
  installation_fee: number;
  contract_type: 'fibre' | 'wireless' | 'hybrid';
}

/**
 * Create contract from approved quote
 *
 * @param quoteId - ID of the approved business quote
 * @param kycSessionId - ID of the completed KYC session
 * @returns Contract ID and contract number
 */
export async function createContractFromQuote(
  quoteId: string,
  kycSessionId: string
): Promise<{ contractId: string; contractNumber: string }> {
  const supabase = await createClient();

  try {
    // 1. Fetch quote data
    const { data: quote, error: quoteError } = await supabase
      .from('business_quotes')
      .select('*')
      .eq('id', quoteId)
      .single();

    if (quoteError || !quote) {
      throw new Error(`Quote not found: ${quoteId}`);
    }

    const quoteData = quote as unknown as QuoteData;

    // 2. Calculate contract dates
    const startDate = new Date();
    const endDate = new Date(startDate);
    endDate.setMonth(endDate.getMonth() + quoteData.contract_term);

    // 3. Calculate total contract value
    // Formula: (monthly_recurring * term) + once_off_fee + installation_fee
    const totalContractValue =
      quoteData.monthly_recurring * quoteData.contract_term +
      (quoteData.once_off_fee || 0) +
      (quoteData.installation_fee || 0);

    // 4. Insert contract record
    const { data: contract, error: insertError } = await supabase
      .from('contracts')
      .insert({
        quote_id: quoteId,
        customer_id: quoteData.customer_id,
        kyc_session_id: kycSessionId,
        contract_type: quoteData.contract_type,
        contract_term_months: quoteData.contract_term,
        start_date: startDate.toISOString().split('T')[0],
        end_date: endDate.toISOString().split('T')[0],
        monthly_recurring: quoteData.monthly_recurring,
        once_off_fee: quoteData.once_off_fee || 0,
        installation_fee: quoteData.installation_fee || 0,
        total_contract_value: totalContractValue,
        status: 'draft',
      })
      .select()
      .single();

    if (insertError || !contract) {
      console.error('Contract insert error:', insertError);
      throw new Error('Failed to create contract');
    }

    // 5. Return contract details
    // Note: contract_number is auto-generated by database trigger (CT-YYYY-NNN)
    return {
      contractId: contract.id,
      contractNumber: contract.contract_number,
    };
  } catch (error) {
    console.error('Error creating contract from quote:', error);
    throw error;
  }
}

/**
 * Get contract by ID with related data
 *
 * @param contractId - Contract UUID
 * @returns Full contract details with quote and KYC data
 */
export async function getContractById(
  contractId: string
): Promise<ContractResponse | null> {
  const supabase = await createClient();

  try {
    const { data: contract, error } = await supabase
      .from('contracts')
      .select('*')
      .eq('id', contractId)
      .single();

    if (error || !contract) {
      console.error('Contract fetch error:', error);
      return null;
    }

    return {
      contractId: contract.id,
      contractNumber: contract.contract_number,
      pdfUrl: contract.pdf_url,
      status: contract.status,
      totalContractValue: contract.total_contract_value,
      startDate: contract.start_date,
      endDate: contract.end_date,
    };
  } catch (error) {
    console.error('Error fetching contract:', error);
    return null;
  }
}

/**
 * Update contract PDF URL after generation
 *
 * @param contractId - Contract UUID
 * @param pdfUrl - URL of generated PDF in Supabase Storage
 */
export async function updateContractPdfUrl(
  contractId: string,
  pdfUrl: string
): Promise<void> {
  const supabase = await createClient();

  const { error } = await supabase
    .from('contracts')
    .update({ pdf_url: pdfUrl })
    .eq('id', contractId);

  if (error) {
    console.error('Error updating contract PDF URL:', error);
    throw new Error('Failed to update contract PDF URL');
  }
}
