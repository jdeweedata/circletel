/**
 * SARS-Compliant Billing Service
 * 
 * Handles invoice generation, credit notes, PDF storage, and audit logging
 * in compliance with South African Revenue Service requirements.
 * 
 * Key Principles:
 * - Invoices are immutable once sent
 * - All changes are audit logged
 * - Corrections use credit notes, not edits
 * - PDFs are stored permanently in Supabase Storage
 * 
 * @module lib/billing/compliant-billing-service
 */

import { createClient } from '@/lib/supabase/server';
import { generateInvoicePDF, buildInvoiceData, COMPANY_DETAILS } from '@/lib/invoices/invoice-pdf-generator';
import { EmailNotificationService } from '@/lib/notifications/notification-service';
import { billingLogger } from '@/lib/logging';

// =============================================================================
// Types
// =============================================================================

export type InvoiceStatus = 'draft' | 'sent' | 'paid' | 'partial' | 'overdue' | 'cancelled' | 'voided';
export type CreditNoteStatus = 'draft' | 'issued' | 'applied';
export type CreditNoteReason = 'billing_error' | 'service_issue' | 'cancellation' | 'price_adjustment' | 'duplicate' | 'other';
export type BillingDate = 1 | 5 | 25 | 30;

export interface InvoiceLineItem {
  description: string;
  quantity: number;
  unit_price: number;  // VAT-inclusive price
  amount: number;      // VAT-inclusive total
  type: 'recurring' | 'installation' | 'pro_rata' | 'equipment' | 'adjustment';
}

export interface GenerateInvoiceParams {
  customer_id: string;
  service_id?: string;
  order_id?: string;
  invoice_type: 'recurring' | 'installation' | 'pro_rata' | 'equipment' | 'adjustment';
  line_items: InvoiceLineItem[];
  period_start?: string;  // YYYY-MM-DD
  period_end?: string;    // YYYY-MM-DD
  due_days?: number;
  notes?: string;
  auto_send?: boolean;    // If true, immediately send and lock
}

export interface CreateCreditNoteParams {
  original_invoice_id: string;
  line_items: InvoiceLineItem[];
  reason: string;
  reason_category: CreditNoteReason;
  notes?: string;
  auto_apply?: boolean;
}

export interface AuditContext {
  user_id?: string;
  user_email?: string;
  user_role?: string;
  ip_address?: string;
  user_agent?: string;
  reason?: string;
}

// =============================================================================
// Compliant Billing Service
// =============================================================================

export class CompliantBillingService {
  
  /**
   * Generate a new invoice with proper VAT calculation
   * Prices are assumed to be VAT-inclusive (South African standard)
   */
  static async generateInvoice(params: GenerateInvoiceParams, audit?: AuditContext) {
    const supabase = await createClient();
    const {
      customer_id,
      service_id,
      order_id,
      invoice_type,
      line_items,
      period_start,
      period_end,
      due_days = 7,
      notes,
      auto_send = false
    } = params;

    // Calculate totals - prices are VAT-INCLUSIVE
    const vatRate = 15.00;
    const totalAmount = line_items.reduce((sum, item) => sum + item.amount, 0);
    // Reverse calculate: subtotal = total / 1.15
    const subtotal = Math.round((totalAmount / (1 + vatRate / 100)) * 100) / 100;
    const vatAmount = Math.round((totalAmount - subtotal) * 100) / 100;

    // Calculate dates
    const invoiceDate = new Date();
    const dueDate = new Date(invoiceDate);
    dueDate.setDate(dueDate.getDate() + due_days);

    // Insert invoice (invoice_number auto-generated by trigger)
    const { data: invoice, error } = await supabase
      .from('customer_invoices')
      .insert({
        customer_id,
        service_id,
        invoice_type,
        invoice_date: invoiceDate.toISOString().split('T')[0],
        due_date: dueDate.toISOString().split('T')[0],
        period_start,
        period_end,
        subtotal,
        vat_rate: vatRate,
        vat_amount: vatAmount,
        total_amount: totalAmount,
        amount_paid: 0,
        line_items,
        status: 'draft',
        notes,
        created_by: audit?.user_id
      })
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to generate invoice: ${error.message}`);
    }

    // If auto_send, generate PDF and send
    if (auto_send) {
      await this.sendInvoice(invoice.id, audit);
    }

    return invoice;
  }

  /**
   * Generate PDF, store it, and mark invoice as sent (locks it)
   */
  static async sendInvoice(invoiceId: string, audit?: AuditContext) {
    const supabase = await createClient();

    // Fetch invoice with customer data
    const { data: invoice, error: fetchError } = await supabase
      .from('customer_invoices')
      .select(`
        *,
        customer:customers(
          id, first_name, last_name, email, phone, account_number,
          business_name, business_registration, tax_number
        )
      `)
      .eq('id', invoiceId)
      .single();

    if (fetchError || !invoice) {
      throw new Error(`Invoice not found: ${invoiceId}`);
    }

    if (invoice.status !== 'draft') {
      throw new Error(`Cannot send invoice in status: ${invoice.status}`);
    }

    // Build invoice data for PDF
    const invoiceData = buildInvoiceData({
      invoice: {
        id: invoice.id,
        invoice_number: invoice.invoice_number,
        invoice_date: invoice.invoice_date,
        due_date: invoice.due_date,
        period_start: invoice.period_start,
        period_end: invoice.period_end,
        subtotal: invoice.subtotal,
        tax_amount: invoice.vat_amount,
        total_amount: invoice.total_amount,
        line_items: invoice.line_items,
        notes: invoice.notes,
        status: invoice.status
      },
      customer: invoice.customer
    });

    // Generate PDF
    const pdfDoc = generateInvoicePDF(invoiceData);
    const pdfBuffer = pdfDoc.output('arraybuffer');
    const pdfBlob = new Blob([pdfBuffer], { type: 'application/pdf' });

    // Upload to Supabase Storage
    const storagePath = `invoices/${invoice.customer_id}/${invoice.invoice_number}.pdf`;
    const { error: uploadError } = await supabase.storage
      .from('invoice-documents')
      .upload(storagePath, pdfBlob, {
        contentType: 'application/pdf',
        upsert: false  // Don't overwrite - immutable
      });

    if (uploadError) {
      throw new Error(`Failed to upload PDF: ${uploadError.message}`);
    }

    // Get signed URL (valid for 1 year)
    const { data: signedUrl } = await supabase.storage
      .from('invoice-documents')
      .createSignedUrl(storagePath, 31536000); // 1 year in seconds

    // Update invoice: set status to 'sent', store PDF URL, lock it
    const { error: updateError } = await supabase
      .from('customer_invoices')
      .update({
        status: 'sent',
        pdf_url: signedUrl?.signedUrl,
        pdf_generated_at: new Date().toISOString(),
        is_locked: true,
        locked_at: new Date().toISOString(),
        locked_reason: 'Invoice sent to customer'
      })
      .eq('id', invoiceId);

    if (updateError) {
      throw new Error(`Failed to update invoice status: ${updateError.message}`);
    }

    // Log audit entry
    await this.logAudit(invoiceId, 'sent', audit, {
      pdf_url: signedUrl?.signedUrl,
      storage_path: storagePath
    });

    // Send invoice email to customer
    if (invoice.customer?.email) {
      try {
        await EmailNotificationService.send({
          to: invoice.customer.email,
          subject: `Your Invoice ${invoice.invoice_number} is Ready - CircleTel`,
          template: 'invoice_sent',
          data: {
            customer_name: `${invoice.customer.first_name} ${invoice.customer.last_name}`,
            invoice_number: invoice.invoice_number,
            invoice_date: this.formatDate(invoice.invoice_date),
            due_date: this.formatDate(invoice.due_date),
            period_start: invoice.period_start ? this.formatDate(invoice.period_start) : null,
            period_end: invoice.period_end ? this.formatDate(invoice.period_end) : null,
            total_amount: invoice.total_amount,
            pdf_url: signedUrl?.signedUrl,
            account_number: invoice.customer.account_number
          },
          tags: {
            template_id: 'invoice_sent',
            invoice_id: invoiceId,
            customer_id: invoice.customer.id,
            notification_type: 'billing'
          }
        });
        billingLogger.info(`Invoice email sent to ${invoice.customer.email} for ${invoice.invoice_number}`);
      } catch (emailError) {
        // Log error but don't fail the invoice send process
        billingLogger.error(`Failed to send invoice email`, { email: invoice.customer.email, invoiceNumber: invoice.invoice_number, error: emailError });
      }
    }

    return {
      invoice_id: invoiceId,
      invoice_number: invoice.invoice_number,
      pdf_url: signedUrl?.signedUrl,
      status: 'sent'
    };
  }

  /**
   * Create a credit note to correct an invoice
   * This is the ONLY way to correct a sent invoice (SARS compliance)
   */
  static async createCreditNote(params: CreateCreditNoteParams, audit?: AuditContext) {
    const supabase = await createClient();
    const {
      original_invoice_id,
      line_items,
      reason,
      reason_category,
      notes,
      auto_apply = false
    } = params;

    // Fetch original invoice
    const { data: originalInvoice, error: fetchError } = await supabase
      .from('customer_invoices')
      .select('*')
      .eq('id', original_invoice_id)
      .single();

    if (fetchError || !originalInvoice) {
      throw new Error(`Original invoice not found: ${original_invoice_id}`);
    }

    // Calculate credit note totals
    const vatRate = 15.00;
    const totalAmount = line_items.reduce((sum, item) => sum + item.amount, 0);
    const subtotal = Math.round((totalAmount / (1 + vatRate / 100)) * 100) / 100;
    const vatAmount = Math.round((totalAmount - subtotal) * 100) / 100;

    // Validate credit amount doesn't exceed invoice amount
    if (totalAmount > originalInvoice.total_amount) {
      throw new Error('Credit note amount cannot exceed original invoice amount');
    }

    // Create credit note
    const { data: creditNote, error: createError } = await supabase
      .from('credit_notes')
      .insert({
        original_invoice_id,
        customer_id: originalInvoice.customer_id,
        subtotal,
        vat_rate: vatRate,
        vat_amount: vatAmount,
        total_amount: totalAmount,
        line_items,
        reason,
        reason_category,
        notes,
        status: 'draft',
        created_by: audit?.user_id
      })
      .select()
      .single();

    if (createError) {
      throw new Error(`Failed to create credit note: ${createError.message}`);
    }

    // If auto_apply, issue and apply the credit note
    if (auto_apply) {
      await this.applyCreditNote(creditNote.id, audit);
    }

    return creditNote;
  }

  /**
   * Issue and apply a credit note
   * Updates the original invoice's amount_paid and potentially status
   */
  static async applyCreditNote(creditNoteId: string, audit?: AuditContext) {
    const supabase = await createClient();

    // Fetch credit note
    const { data: creditNote, error: fetchError } = await supabase
      .from('credit_notes')
      .select('*, original_invoice:customer_invoices(*)')
      .eq('id', creditNoteId)
      .single();

    if (fetchError || !creditNote) {
      throw new Error(`Credit note not found: ${creditNoteId}`);
    }

    if (creditNote.status !== 'draft') {
      throw new Error(`Credit note already ${creditNote.status}`);
    }

    // Update credit note status
    const { error: updateCnError } = await supabase
      .from('credit_notes')
      .update({
        status: 'applied',
        applied_at: new Date().toISOString()
      })
      .eq('id', creditNoteId);

    if (updateCnError) {
      throw new Error(`Failed to apply credit note: ${updateCnError.message}`);
    }

    // Update original invoice - add credit to amount_paid
    const originalInvoice = creditNote.original_invoice;
    const newAmountPaid = (originalInvoice.amount_paid || 0) + creditNote.total_amount;
    const newStatus = newAmountPaid >= originalInvoice.total_amount ? 'paid' : 
                      newAmountPaid > 0 ? 'partial' : originalInvoice.status;

    const { error: updateInvError } = await supabase
      .from('customer_invoices')
      .update({
        amount_paid: newAmountPaid,
        status: newStatus,
        payment_reference: `Credit Note: ${creditNote.credit_note_number}`
      })
      .eq('id', originalInvoice.id);

    if (updateInvError) {
      throw new Error(`Failed to update invoice: ${updateInvError.message}`);
    }

    // Log audit
    await this.logAudit(originalInvoice.id, 'credit_applied', audit, {
      credit_note_id: creditNoteId,
      credit_note_number: creditNote.credit_note_number,
      credit_amount: creditNote.total_amount
    });

    return {
      credit_note_id: creditNoteId,
      credit_note_number: creditNote.credit_note_number,
      invoice_id: originalInvoice.id,
      new_amount_paid: newAmountPaid,
      new_status: newStatus
    };
  }

  /**
   * Void an invoice (only for draft invoices or with proper authorization)
   */
  static async voidInvoice(invoiceId: string, reason: string, audit?: AuditContext) {
    const supabase = await createClient();

    // Fetch invoice
    const { data: invoice, error: fetchError } = await supabase
      .from('customer_invoices')
      .select('*')
      .eq('id', invoiceId)
      .single();

    if (fetchError || !invoice) {
      throw new Error(`Invoice not found: ${invoiceId}`);
    }

    // Can only void draft invoices directly
    // Sent invoices require a credit note
    if (invoice.status !== 'draft') {
      throw new Error(`Cannot void invoice in status '${invoice.status}'. Use credit note for sent invoices.`);
    }

    // Update invoice
    const { error: updateError } = await supabase
      .from('customer_invoices')
      .update({
        status: 'voided',
        voided_at: new Date().toISOString(),
        voided_by: audit?.user_id,
        void_reason: reason
      })
      .eq('id', invoiceId);

    if (updateError) {
      throw new Error(`Failed to void invoice: ${updateError.message}`);
    }

    // Log audit
    await this.logAudit(invoiceId, 'voided', { ...audit, reason });

    return { invoice_id: invoiceId, status: 'voided', reason };
  }

  /**
   * Record a payment against an invoice
   */
  static async recordPayment(
    invoiceId: string,
    amount: number,
    paymentMethod: string,
    paymentReference: string,
    audit?: AuditContext
  ) {
    const supabase = await createClient();

    // Fetch invoice
    const { data: invoice, error: fetchError } = await supabase
      .from('customer_invoices')
      .select('*')
      .eq('id', invoiceId)
      .single();

    if (fetchError || !invoice) {
      throw new Error(`Invoice not found: ${invoiceId}`);
    }

    if (['paid', 'voided', 'cancelled'].includes(invoice.status)) {
      throw new Error(`Cannot record payment for invoice in status: ${invoice.status}`);
    }

    // Calculate new amount paid
    const newAmountPaid = Math.round(((invoice.amount_paid || 0) + amount) * 100) / 100;
    const newStatus = newAmountPaid >= invoice.total_amount ? 'paid' : 'partial';

    // Update invoice
    const { error: updateError } = await supabase
      .from('customer_invoices')
      .update({
        amount_paid: newAmountPaid,
        status: newStatus,
        payment_method: paymentMethod,
        payment_reference: paymentReference,
        paid_at: newStatus === 'paid' ? new Date().toISOString() : null
      })
      .eq('id', invoiceId);

    if (updateError) {
      throw new Error(`Failed to record payment: ${updateError.message}`);
    }

    // Log audit
    await this.logAudit(invoiceId, 'payment_recorded', audit, {
      amount,
      payment_method: paymentMethod,
      payment_reference: paymentReference,
      new_amount_paid: newAmountPaid,
      new_status: newStatus
    });

    return {
      invoice_id: invoiceId,
      amount_paid: newAmountPaid,
      status: newStatus
    };
  }

  /**
   * Get invoice audit history
   */
  static async getAuditHistory(invoiceId: string) {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from('invoice_audit_log')
      .select('*')
      .eq('invoice_id', invoiceId)
      .order('created_at', { ascending: false });

    if (error) {
      throw new Error(`Failed to fetch audit history: ${error.message}`);
    }

    return data;
  }

  /**
   * Log an audit entry
   */
  private static async logAudit(
    invoiceId: string,
    action: string,
    audit?: AuditContext,
    additionalData?: Record<string, any>
  ) {
    const supabase = await createClient();

    await supabase
      .from('invoice_audit_log')
      .insert({
        invoice_id: invoiceId,
        action,
        performed_by: audit?.user_id,
        performed_by_email: audit?.user_email,
        performed_by_role: audit?.user_role,
        ip_address: audit?.ip_address,
        user_agent: audit?.user_agent,
        reason: audit?.reason,
        new_data: additionalData
      });
  }

  /**
   * Format date for email display (e.g., "29 November 2025")
   */
  private static formatDate(dateStr: string): string {
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-ZA', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  }

  /**
   * Check for overdue invoices and update status
   */
  static async processOverdueInvoices() {
    const supabase = await createClient();
    const today = new Date().toISOString().split('T')[0];

    const { data: overdueInvoices, error } = await supabase
      .from('customer_invoices')
      .update({ status: 'overdue' })
      .eq('status', 'sent')
      .lt('due_date', today)
      .select();

    if (error) {
      throw new Error(`Failed to process overdue invoices: ${error.message}`);
    }

    return {
      processed: overdueInvoices?.length || 0,
      invoices: overdueInvoices
    };
  }
}
