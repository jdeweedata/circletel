#!/usr/bin/env tsx
/**
 * ZOHO Billing Invoice Backfill Script
 *
 * Syncs existing CircleTel invoices to ZOHO Billing
 * (Note: Recurring invoices are auto-generated by ZOHO from subscriptions)
 *
 * Usage:
 *   npx tsx scripts/zoho-backfill-invoices.ts [--dry-run] [--batch-size=10]
 */

import { config } from 'dotenv';
import { resolve } from 'path';

// Load .env.local explicitly
config({ path: resolve(process.cwd(), '.env.local') });
import { createClient } from '@supabase/supabase-js';
import { syncInvoiceToZohoBilling } from '../lib/integrations/zoho/invoice-sync-service';

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  console.error('âŒ Missing required environment variables');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');
const batchSizeArg = args.find(arg => arg.startsWith('--batch-size='));
const batchSize = batchSizeArg ? parseInt(batchSizeArg.split('=')[1]) : 10;

interface Invoice {
  id: string;
  invoice_number: string;
  total_amount: number;
  status: string;
  zoho_billing_invoice_id: string | null;
  customer: {
    email: string;
    account_number: string;
    zoho_billing_customer_id: string | null;
    account_type: string;
  };
}

async function syncInvoice(invoice: Invoice, index: number, total: number) {
  console.log(`\n[${index + 1}/${total}] Processing invoice: ${invoice.invoice_number}`);
  console.log(`  Customer: ${invoice.customer.email}`);
  console.log(`  Type: ${invoice.invoice_type}`);
  console.log(`  Amount: R${invoice.total_amount}`);

  if (invoice.customer.account_type === 'internal_test') {
    console.log(`  â­ï¸  Skipped: Internal test account`);
    return { success: true, error: 'Internal test account - skipped' };
  }

  if (!invoice.customer.zoho_billing_customer_id) {
    console.log(`  âš ï¸  Skipped: Customer not synced to ZOHO`);
    return { success: false, error: 'Customer not synced' };
  }

  if (isDryRun) {
    console.log('  ðŸ” DRY RUN: Would create ZOHO invoice');
    return { success: true, dry_run: true };
  }

  try {
    const result = await syncInvoiceToZohoBilling(invoice.id);
    if (result.success) {
      console.log(`  âœ… Created ZOHO invoice: ${result.zoho_invoice_id}`);
    } else {
      console.error(`  âŒ Failed: ${result.error}`);
    }
    return result;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`  âŒ Failed: ${errorMessage}`);
    return { success: false, error: errorMessage };
  }
}

async function main() {
  console.log('\nðŸ”„ ZOHO Billing Invoice Backfill');
  console.log('â•'.repeat(60));
  console.log(`Mode: ${isDryRun ? 'ðŸ” DRY RUN' : 'âœ… LIVE SYNC'}`);
  console.log(`Batch Size: ${batchSize}`);
  console.log('â•'.repeat(60));

  console.log('\nðŸ“Š Fetching invoices...');

  const { data: invoices, error: fetchError } = await supabase
    .from('customer_invoices')
    .select(`
      id,
      invoice_number,
      total_amount,
      status,
      zoho_billing_invoice_id,
      customer:customers!inner(
        email,
        account_number,
        zoho_billing_customer_id,
        account_type
      )
    `)
    .order('invoice_date', { ascending: true });

  if (fetchError) {
    console.error('âŒ Error fetching invoices:', fetchError);
    process.exit(1);
  }

  if (!invoices || invoices.length === 0) {
    console.log('âœ… No invoices found');
    return;
  }

  const productionInvoices = invoices.filter(
    inv => inv.customer && inv.customer.account_type !== 'internal_test'
  );

  const needingSync = productionInvoices.filter(inv => !inv.zoho_billing_invoice_id);
  const alreadySynced = productionInvoices.filter(inv => inv.zoho_billing_invoice_id);

  console.log(`\nðŸ“ˆ Invoice Status:`);
  console.log(`  Total Invoices: ${productionInvoices.length}`);
  console.log(`  Already Synced: ${alreadySynced.length}`);
  console.log(`  Needing Sync: ${needingSync.length}`);

  if (needingSync.length === 0) {
    console.log('\nâœ… All invoices already synced!');
    return;
  }

  console.log(`\nðŸš€ Starting invoice sync...`);
  const startTime = Date.now();

  const results = {
    total: needingSync.length,
    synced: 0,
    skipped: 0,
    failed: 0,
    errors: [] as Array<{ invoice: string; error: string }>
  };

  for (let i = 0; i < needingSync.length; i++) {
    const invoice = needingSync[i];
    const result = await syncInvoice(invoice, i, needingSync.length);

    if (result.success) {
      if (result.dry_run || result.error?.includes('skipped')) {
        results.skipped++;
      } else {
        results.synced++;
      }
    } else {
      results.failed++;
      results.errors.push({
        invoice: invoice.invoice_number,
        error: result.error || 'Unknown error'
      });
    }

    // Delay between invoices (500ms)
    if (i < needingSync.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }

  const duration = ((Date.now() - startTime) / 1000).toFixed(2);

  console.log('\n');
  console.log('â•'.repeat(60));
  console.log('ðŸ“Š Backfill Results');
  console.log('â•'.repeat(60));
  console.log(`Total Invoices: ${results.total}`);
  console.log(`âœ… Successfully Synced: ${results.synced}`);
  console.log(`â­ï¸  Skipped: ${results.skipped}`);
  console.log(`âŒ Failed: ${results.failed}`);
  console.log(`â±ï¸  Duration: ${duration} seconds`);

  if (results.errors.length > 0) {
    console.log(`\nâŒ Failed Invoices:`);
    results.errors.forEach(({ invoice, error }) => {
      console.log(`  - ${invoice}: ${error}`);
    });
  }

  if (isDryRun) {
    console.log(`\nðŸ” This was a DRY RUN. No actual changes were made.`);
  } else {
    console.log(`\nâœ… Invoice backfill complete!`);
  }
}

main().catch(error => {
  console.error('\nðŸ’¥ Fatal error:', error);
  process.exit(1);
});
