/**
 * POST /api/payments/webhook
 * NetCash Pay Now Webhook Handler
 * 
 * Handles payment confirmation from NetCash
 * Auto-creates order and triggers RICA submission on successful payment
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import crypto from 'crypto';

/**
 * Verify NetCash webhook signature
 * Uses HMAC-SHA256 to verify webhook authenticity
 */
function verifyNetCashSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const computedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(computedSignature)
  );
}

/**
 * NetCash Webhook Handler
 * 
 * Events:
 * - payment.completed: Payment successful
 * - payment.failed: Payment failed
 * - payment.pending: Payment pending (EFT, etc.)
 */
export async function POST(request: NextRequest) {
  const supabase = await createClient();

  try {
    // 1. Verify webhook signature
    const signature = request.headers.get('x-netcash-signature');
    const rawBody = await request.text();
    
    if (!signature) {
      console.error('[NetCash Webhook] Missing signature');
      return NextResponse.json(
        { error: 'Missing signature' },
        { status: 401 }
      );
    }

    const webhookSecret = process.env.NETCASH_WEBHOOK_SECRET;
    if (!webhookSecret) {
      console.error('[NetCash Webhook] Webhook secret not configured');
      return NextResponse.json(
        { error: 'Webhook secret not configured' },
        { status: 500 }
      );
    }

    const isValid = verifyNetCashSignature(rawBody, signature, webhookSecret);
    if (!isValid) {
      console.error('[NetCash Webhook] Invalid signature');
      return NextResponse.json(
        { error: 'Invalid signature' },
        { status: 401 }
      );
    }

    // 2. Parse webhook payload
    const payload = JSON.parse(rawBody);
    const {
      event_type,
      transaction_id,
      invoice_id,
      amount,
      status,
      payment_method,
      customer_email,
      timestamp,
    } = payload;

    console.log('[NetCash Webhook] Received event:', {
      event_type,
      transaction_id,
      invoice_id,
      status,
    });

    // 3. Check idempotency (prevent duplicate processing)
    const { data: existingWebhook } = await supabase
      .from('payment_webhooks')
      .select('id')
      .eq('transaction_id', transaction_id)
      .single();

    if (existingWebhook) {
      console.log('[NetCash Webhook] Duplicate webhook, ignoring');
      return NextResponse.json({ message: 'Webhook already processed' });
    }

    // 4. Log webhook event
    await supabase.from('payment_webhooks').insert({
      transaction_id,
      event_type,
      payload: payload,
      processed_at: new Date().toISOString(),
    });

    // 5. Update invoice status
    const { data: invoice, error: invoiceError } = await supabase
      .from('invoices')
      .select('*, contract_id')
      .eq('id', invoice_id)
      .single();

    if (invoiceError || !invoice) {
      console.error('[NetCash Webhook] Invoice not found:', invoice_id);
      return NextResponse.json(
        { error: 'Invoice not found' },
        { status: 404 }
      );
    }

    // 6. Update invoice based on payment status
    if (status === 'completed' || status === 'approved') {
      await supabase
        .from('invoices')
        .update({
          payment_status: 'paid',
          payment_method: payment_method,
          payment_reference: transaction_id,
          total_paid: amount,
          paid_at: timestamp,
          updated_at: new Date().toISOString(),
        })
        .eq('id', invoice_id);

      console.log('[NetCash Webhook] Invoice marked as paid:', invoice_id);

      // 7. AUTO-CREATE ORDER on successful payment
      const { data: contract } = await supabase
        .from('contracts')
        .select('*, quote:business_quotes(*), kyc_session:kyc_sessions(*)')
        .eq('id', invoice.contract_id)
        .single();

      if (contract && contract.quote) {
        const quote = contract.quote;
        
        // Create consumer_orders record
        const { data: order, error: orderError } = await supabase
          .from('consumer_orders')
          .insert({
            // Order number auto-generated by trigger
            
            // Customer info from quote
            first_name: quote.contact_name?.split(' ')[0] || '',
            last_name: quote.contact_name?.split(' ').slice(1).join(' ') || '',
            email: quote.contact_email,
            phone: quote.contact_phone,

            // Address
            installation_address: quote.service_address,
            billing_same_as_installation: true,

            // Product selection
            service_package_id: quote.service_package_id,
            package_name: quote.package_details?.name,
            package_speed: quote.package_details?.speed,
            package_price: quote.monthly_price,
            installation_fee: quote.installation_fee,
            router_included: quote.router_included,

            // Payment
            payment_method: payment_method,
            payment_status: 'paid',
            payment_reference: transaction_id,
            total_paid: amount,

            // Status
            status: 'payment_received',

            // Installation
            preferred_installation_date: quote.preferred_installation_date,

            // Tracking
            lead_source: 'b2b_quote',
            contract_id: contract.id,
          })
          .select()
          .single();

        if (orderError) {
          console.error('[NetCash Webhook] Failed to create order:', orderError);
        } else {
          console.log('[NetCash Webhook] Order created:', order.order_number);

          // 8. TRIGGER RICA SUBMISSION (if KYC approved)
          if (contract.kyc_session?.verification_result === 'approved') {
            try {
              // Call RICA submission API
              const ricaResponse = await fetch(
                `${request.nextUrl.origin}/api/activation/rica-submit`,
                {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    kycSessionId: contract.kyc_session.id,
                    orderId: order.id,
                    serviceLines: [
                      {
                        iccid: null, // Will be assigned during installation
                        serviceType: quote.service_type,
                        productName: quote.package_details?.name,
                      },
                    ],
                  }),
                }
              );

              if (ricaResponse.ok) {
                console.log('[NetCash Webhook] RICA submission triggered');
              } else {
                console.error('[NetCash Webhook] RICA submission failed');
              }
            } catch (ricaError) {
              console.error('[NetCash Webhook] RICA submission error:', ricaError);
            }
          }

          // 9. Update contract status
          await supabase
            .from('contracts')
            .update({
              status: 'payment_received',
              updated_at: new Date().toISOString(),
            })
            .eq('id', contract.id);
        }
      }
    } else if (status === 'failed' || status === 'declined') {
      await supabase
        .from('invoices')
        .update({
          payment_status: 'failed',
          updated_at: new Date().toISOString(),
        })
        .eq('id', invoice_id);

      console.log('[NetCash Webhook] Invoice marked as failed:', invoice_id);
    } else if (status === 'pending') {
      await supabase
        .from('invoices')
        .update({
          payment_status: 'pending',
          updated_at: new Date().toISOString(),
        })
        .eq('id', invoice_id);

      console.log('[NetCash Webhook] Invoice marked as pending:', invoice_id);
    }

    // 10. Return success
    return NextResponse.json({
      message: 'Webhook processed successfully',
      transaction_id,
      status,
    });
  } catch (error) {
    console.error('[NetCash Webhook] Error processing webhook:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
