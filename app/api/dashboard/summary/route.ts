/**
 * Dashboard Summary API
 * GET /api/dashboard/summary
 * 
 * Returns comprehensive dashboard summary aggregating all customer data
 * Task 3.7: Dashboard Summary API
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClientWithSession } from '@/lib/supabase/server';
import { PaymentMethodService } from '@/lib/billing/payment-method-service';

/**
 * GET /api/dashboard/summary
 * 
 * Returns:
 * - Customer details (account_number, account_status)
 * - Services list with current status
 * - Billing summary (balance, next payment)
 * - Recent orders (from consumer_orders)
 * - Recent invoices (last 5)
 * - Stats (active services, orders, overdue invoices)
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClientWithSession();

    // Get authenticated user from session
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { 
          success: false,
          error: 'Unauthorized' 
        },
        { status: 401 }
      );
    }
    
    // Get customer details
    const { data: customer, error: customerError } = await supabase
      .from('customers')
      .select('id, first_name, last_name, email, phone, account_number, account_status, created_at')
      .eq('auth_user_id', user.id)
      .single();
    
    // If customer record doesn't exist, create a basic one from auth user data
    if (customerError || !customer) {
      // Create minimal customer record from auth user data
      const { data: newCustomer, error: createError } = await supabase
        .from('customers')
        .insert({
          auth_user_id: user.id,
          first_name: user.user_metadata?.first_name || user.user_metadata?.name || 'User',
          last_name: user.user_metadata?.last_name || '',
          email: user.email || '',
          phone: user.user_metadata?.phone || '',
          account_status: 'pending',
          account_number: null, // Will be generated by trigger
        })
        .select('id, first_name, last_name, email, phone, account_number, account_status, created_at')
        .single();
      
      if (createError || !newCustomer) {
        return NextResponse.json(
          { 
            success: false,
            error: 'Failed to create customer record', 
            details: createError?.message 
          },
          { status: 500 }
        );
      }
      
      // Return minimal summary for new customer
      return NextResponse.json({
        success: true,
        data: {
          customer: {
            id: newCustomer.id,
            firstName: newCustomer.first_name,
            lastName: newCustomer.last_name,
            email: newCustomer.email,
            phone: newCustomer.phone,
            accountNumber: newCustomer.account_number || '',
            customerSince: newCustomer.created_at
          },
          services: [],
          billing: null,
          orders: [],
          invoices: [],
          stats: {
            activeServices: 0,
            totalOrders: 0,
            pendingOrders: 0,
            overdueInvoices: 0,
            accountBalance: 0
          }
        }
      });
    }
    
    // Parallel queries for better performance
    const [
      servicesResult,
      billingResult,
      ordersResult,
      invoicesResult,
      transactionsResult
    ] = await Promise.all([
      // Get all services
      supabase
        .from('customer_services')
        .select('*')
        .eq('customer_id', customer.id)
        .order('created_at', { ascending: false }),
      
      // Get billing info
      supabase
        .from('customer_billing')
        .select('*')
        .eq('customer_id', customer.id)
        .single(),
      
      // Get recent orders
      supabase
        .from('consumer_orders')
        .select('id, order_number, status, total_paid, created_at, package_name')
        .eq('customer_id', customer.id)
        .order('created_at', { ascending: false })
        .limit(5),
      
      // Get recent invoices
      supabase
        .from('customer_invoices')
        .select('*')
        .eq('customer_id', customer.id)
        .order('invoice_date', { ascending: false })
        .limit(5),
      
      // Get recent transactions
      supabase
        .from('payment_transactions')
        .select('*')
        .eq('customer_id', customer.id)
        .order('transaction_date', { ascending: false })
        .limit(5)
    ]);
    
    const services = servicesResult.data || [];
    const billing = billingResult.data;
    const orders = ordersResult.data || [];
    const invoices = invoicesResult.data || [];
    const transactions = transactionsResult.data || [];
    
    // Get primary payment method
    const primaryPaymentMethod = await PaymentMethodService.getPrimaryMethod(customer.id);
    
    // Calculate statistics
    const activeServices = services.filter(s => s.status === 'active');
    const pendingServices = services.filter(s => s.status === 'pending');
    const suspendedServices = services.filter(s => s.status === 'suspended');
    
    const today = new Date().toISOString().split('T')[0];
    const unpaidInvoices = invoices.filter(inv => inv.status === 'unpaid');
    const overdueInvoices = unpaidInvoices.filter(inv => inv.due_date < today);
    
    const totalUnpaid = unpaidInvoices.reduce((sum, inv) => sum + (inv.total_amount || 0), 0);
    const totalOverdue = overdueInvoices.reduce((sum, inv) => sum + (inv.total_amount || 0), 0);
    
    // Get next billing date from active services
    const nextBillingDates = activeServices
      .map(s => s.next_billing_date)
      .filter(d => d)
      .sort();
    const nextBillingDate = nextBillingDates.length > 0 ? nextBillingDates[0] : null;
    
    // Calculate monthly recurring
    const monthlyRecurring = activeServices.reduce((sum, s) => sum + (s.monthly_price || 0), 0);
    
    // Build summary response matching DashboardData interface
    const summary = {
      customer: {
        id: customer.id,
        email: customer.email,
        firstName: customer.first_name,
        lastName: customer.last_name,
        phone: customer.phone,
        customerSince: customer.created_at,
        accountNumber: customer.account_number || ''
      },
      
      services: services.map(s => ({
        id: s.id,
        package_name: s.package_name,
        service_type: s.service_type,
        status: s.status,
        monthly_price: s.monthly_price,
        installation_address: s.installation_address,
        speed_down: s.speed_down || 0,
        speed_up: s.speed_up || 0
      })),
      
      billing: billing ? {
        account_balance: billing.account_balance || 0,
        payment_method: primaryPaymentMethod?.payment_type || 'Not set',
        payment_status: (billing.account_balance || 0) > 0 ? 'overdue' : 'current',
        next_billing_date: nextBillingDate || '',
        days_overdue: overdueInvoices.length > 0 ? 
          Math.max(...overdueInvoices.map(inv => {
            const dueDate = new Date(inv.due_date);
            const now = new Date();
            return Math.floor((now.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));
          })) : 0
      } : null,
      
      orders: orders.map(o => ({
        id: o.id,
        order_number: o.order_number,
        status: o.status,
        total_amount: o.total_paid || 0,
        created_at: o.created_at
      })),
      
      invoices: invoices.map(inv => ({
        id: inv.id,
        invoice_number: inv.invoice_number,
        invoice_date: inv.invoice_date,
        total_amount: inv.total_amount,
        amount_due: inv.amount_due,
        status: inv.status
      })),
      
      stats: {
        activeServices: activeServices.length,
        totalOrders: orders.length,
        pendingOrders: orders.filter(o => o.status === 'pending').length,
        overdueInvoices: overdueInvoices.length,
        accountBalance: billing?.account_balance || 0
      }
    };
    
    return NextResponse.json({
      success: true,
      data: summary
    });
    
  } catch (error) {
    console.error('Unexpected error:', error);
    return NextResponse.json(
      { 
        success: false,
        error: 'Internal server error' 
      },
      { status: 500 }
    );
  }
}
